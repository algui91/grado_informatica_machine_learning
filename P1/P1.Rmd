---
title: "Aprendizaje Automático - Práctica 1"
author: "Alejandro Alcalde"
date: "March 3, 2016"
mainfont: Ubuntu Light
monofont: "Ubuntu Mono"
fontsize: 12pt
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    highlight: zenburn
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1000000007)
```



# Ejercicio de Generación y Visualización de datos

## Ejercicio 1

Construir una función _lista = simula_unif (N, dim, rango)_ que calcule una lista de longitud _N_ de vectores de dimensión _dim_ conteniendo números aleatorios uniformes en el intervalo _rango_.

```{r}
simula_unif <- function(N, dimen = 1, rango = c(0:1)) {
  # Generate a list of vectors populated with uniform distributed random numbers
  #
  # Args:
  #   N: Length of the list
  #   dimen: The dimension of each vector in the list
  #   rango: Range to use generating the numbers
  #
  # Returns:
  #   A list of vectors populated randomly
  array(runif(dimen*N, rango[1], rango[2]), dim = c(N, dimen))
}

simula_unif(10, 5, c(10,100))
simula_unif(10, 2)
simula_unif(10)
```

## Ejercicio 2

Construir una función _lista = simula_gaus(N, dim, sigma)_ que calcule una lista de longitud _N_ de vectores de dimensión _dim_ conteniendo números aleatorios gaussianos de media 0 y varianza dadas por el vector de _sigma_.

```{r}
simula_gauss <- function(N, dimen = 1, sig = 1){
  # Generate a list of vectors populated using the normal (Gaussian) distribution
  #
  # Args:
  #   N: Length of the list
  #   dimen: The dimension of each vector in the list
  #   sigma: Vector of Standard deviations
  #
  # Returns:
  #   A list of vectors populated randomly
  array(rnorm(dimen*N, sd = sig), dim = c(dimen, N))
}

simula_gauss(10, 5, c(1,2))
```

## Ejercicio 3

Suponer _N=50, dim=2, rango=[-50,+50]_ en cada dimensión. Dibujar una gráfica de la salida de la función correspondiente.

```{r}
datos = simula_unif(50, 2, c(-50,50)); datos
plot(datos[1,],datos[2,], col=2, xlab="x",ylab="y", 
     main="Gráfica datos de simula_unif(50, 2, c(-50,50))")
plot(datos[1,],datos[2,], col = "red", type = "b", 
     main = "Gráfica datos de simula_unif(50, 2, c(-50,50))", lwd = 2, lty = 3)
```

## Ejercicio 4

Suponer _N=50, dim=2, $\sigma=[5,7]$_ dibujar una gráfica de la salida de la función correspondiente.

```{r}
datos = simula_gauss(50, 2, c(5,7)); datos

plot(datos[1,],datos[2,], col=2, xlab="x",ylab="y", 
     main="Gráfica datos de  simula_gauss(50, 2, c(5,7))")
# points(datos[1,],datos[2,])
plot(datos[1,],datos[2,], col = "red", type = "b",
     main = "Gráfica datos de simula_gauss(50, 2, c(5,7))", lwd = 2, lty = 3)
```

## Ejercicio 5

Construir la función _v = simula_recta(intervalo)_ que calcula los parámetros _v = (a,b)_ de una recta aleatoria, _y = ax + b_, que corte al cuadrado _[-50, 50] x [-50, 50]_.

```{r}

simula_recta <- function(interval = c(-50, 50)){
  # Computes the slope and intercept values of two points in the given interval
  #
  # Args:
  #   interval: Interval from which to pick to random points
  #
  # Returns:
  #   A vector [m, l, p1, p2] where:
  #     - m is the slope 
  #     - l is the intercept
  #     - p1, p2, are the points randomly selected
  p1 = runif(2, interval[1], interval[2]);
  p2 = runif(2, interval[1], interval[2]);
  
  ## Compute the slope
  m = (p1[2] - p2[2]) / (p1[1] - p2[1])
  
  # Compute y − y1 = m(x − x1)
  line = m * (p1[1] - p2[1]) + p2[2]
  
  c(m, line, p1, p2)
}

interval = c(-100, 100);
result = simula_recta(interval)
m = result[1]
line = result[2]
p1 = c(result[3],result[4])
p2 = c(result[5], result[6])
data = rbind(p1, p2)

plot(interval, interval, type= "n", 
     sub = paste(c("p1=", p1, "p2=", p2), collapse = " "), 
     main = "Line that passes throught points P1, P2",
     xlab = paste(c("m=", m, "line=", line), collapse = " "),
     ylab = "")
points(p1, p2)
lines(p1, p2, lty="solid", col="red")
```

## Ejercicio 6

Generar una muestra 2D de puntos usando _simula_unif_ y etiquetar la muestra usando el signo de la función $f(x,y) = y - ax - b$ de cada punto a una recta simulada con _simula_recta_. Mostrar una gráfica con el resultado de la muestra etiquetada junto con la recta usada para ello.

```{r}
interval = c(-100, 100)
# Generate a set of points
x = simula_unif(5000, 2, interval);

fsign <- function(x, y, m, b){
  # Function to label a 2D Point
  y - m*x - b
}

straight = simula_recta(interval)
m = straight[1]
line = straight[2]
p1 = c(straight[3],straight[4])
p2 = c(straight[5], straight[6])

# Apply fsign to each point of the set, each x,y will be passed to fsign
result = mapply(fsign, x[,1], x[,2], m = m, b = line)
# Label the result with -1/1
result[result >= 0] = 1
result[result < 0] = -1
# Create a data frame to store the result
datafsign = data.frame(x = x[,1], y = x[,2], result = result)

# Draw the result
plot(datafsign$x,datafsign$y, col=ifelse(datafsign$result == 1, "blue", "red"), pch=20,
     main = "Points labeled in function of y - m*x - b",
     xlab = paste(c("m=", m, "line=", line), collapse = " "),
     sub = paste(c("Interval = ", interval), collapse = " "),
     ylab = "")
abline(line,m)
```

## Ejercicio 7

Usar la muestra generada en el apartado anterior y etiquetarla con +1, -1 usando el signo de cada una de las siguientes funciones.

- $f(x, y) = (x - 10)^2 + (y - 20)^2 - 400$
- $f(x, y) = 0.5(x + 10)^2 + (y - 20)^2 - 400$
- $f(x, y) = 0.5(x - 10)^2 - (y + 20)^2 - 400$
- $f(x, y) = y - 20x^2 - 5x + 3$

Visualizar el resultado del etiquetado de cada función junto con su gráfica y comparar el resultado con el caso lineal. ¿Qué consecuencias extrae sobre las regiones positiva y negativa?

```{r}
# Define the functions
f1 <- function(x, y) {
  (x - 10) ^ 2 + (y - 20) ^ 2 - 400
}
f2 <- function(x, y){
  0.5 * (x + 10)^2 + (y - 20)^2 - 400
}
f3 <- function(x, y){
  0.5 * (x - 10)^2 - (y + 20)^2 - 400
}
f4 <- function(x, y){
  y - 20*x^2 - 5*x + 3
}

# Generate a vector of functions
multi.fun <- function(x, y) {
      c(f1 = f1(x, y), f2 = f2(x, y), f3 = f3(x, y), f4 = f4(x, y))
}

# Apply the functions
result = mapply(multi.fun, x[,1], x[,2])

# Label the results
result[result >= 0] = 1
result[result < 0] = -1

# Create a data frame to store the result
datafunctions = data.frame(x = x[,1], y = x[,2], 
                  f1 = result[1,], f2 = result[2,], f3 = result[3,], f4 = result[4,])

# Draw the result
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f1==1, "blue", "red"), 
     pch=20,
     main = "f1",
     ylab = "",
     xlab = "")
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f2==1, "blue", "red"), 
     pch=20,
     main = "f2",
     ylab = "",
     xlab = "")
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f3==1, "blue", "red"), 
     pch=20,
     main = "f3",
     ylab = "",
     xlab = "")
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f4==1, "blue", "red"), 
     pch=20,
     main = "f4",
     ylab = "",
     xlab = "")
```

Si observamos el caso lineal, vemos que las muestras son separables por una línea recta. Esto se debe a que la función que generó el etiquetado ($f(x,y) = y - ax - b$) es lineal.

Las cuatro funciones usadas para el etiquetado en esta ocasión, son __no lineales__, lo cual implica que los datos etiquetados no serán separables por una simple recta. Se necesita una función más compleja que pueda realizar el particionamiento de los datos positivos y negativos.

## Ejercicio 8

Considerar de nuevo la muestra etiquetada en el ejercicio 6. Modifique las etiquetas de un 10% aleatorio de muestras positivas y otro 10% aleatorio de negativas.

- Visualice los puntos con las nuevas etiquetas y la recta del ejercicio 6
- En una gráfica a parte visualice de nuevo los mismos puntos pero junto con las funciones del ejercicio 7.

Observe las gráficas y diga qué consecuencias extrae del proceso de modificación de etiquetas en el proceso de aprendizaje.

Para el primer apartado, cambiamos el 10% de las muestras positivas y negativas y obtenemos:
```{r Exercise 8.a}
getPercentageOfData <- function(x, condition = 1, percentage = .1){
  # Get the percentage of samples that meet condition
  #
  # Args:
  #   x: A vector containing the data
  #   condition: Condition that the data need to satisfy
  #   percentaje: What percentage of samples to get
  #
  # Returns:
  #   Indexes of the percentage of the samples that meet the condition
  meetCondition = which(x == condition)
  sample(meetCondition, length(meetCondition) * percentage)
}

# Get a 10% of samples labeled with a 1
indexPositive = getPercentageOfData(datafsign$result)
datafsign$result[indexPositive] = -1

indexNegative = getPercentageOfData(datafsign$result, -1)
datafsign$result[indexNegative] = 1

# Draw the result
plot(datafsign$x,datafsign$y, col=ifelse(datafsign$result == 1, "blue", "red"), pch=20,
     main = "Points labeled in function of y - m*x - b",
     xlab = paste(c("m=", m, "line=", line), collapse = " "),
     sub = paste(c("Interval = ", interval), collapse = " "),
     ylab = "")
abline(line,m)
```
La única observación que puede hacerse, es que ahora los datos ya no son separables.

```{r Exercise 8.b}
# Get a 10% of samples labeled with a 1 in all 4 functions
indexPositive = lapply(datafunctions[3:6], getPercentageOfData)
# Change 1 by -1
datafunctions$f1[indexPositive$f1] = -1
datafunctions$f2[indexPositive$f2] = -1
datafunctions$f3[indexPositive$f3] = -1
datafunctions$f4[indexPositive$f4] = -1

# Get a 10% of samples labeled with a 1 in all 4 functions
indexNegative = lapply(datafunctions[3:6], getPercentageOfData, condition = -1)
# Change -1 by 1
datafunctions$f1[indexNegative$f1] = 1
datafunctions$f2[indexNegative$f2] = 1
datafunctions$f3[indexNegative$f3] = 1
datafunctions$f4[indexNegative$f4] = 1

# Draw the result
par(mfrow = c(2,2))
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f1==1, "blue", "red"), 
     pch=20,
     main = "f1",
     ylab = "",
     xlab = "")
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f2==1, "blue", "red"), 
     pch=20,
     main = "f2",
     ylab = "",
     xlab = "")
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f3==1, "blue", "red"), 
     pch=20,
     main = "f3",
     ylab = "",
     xlab = "")
plot(datafunctions$x,datafunctions$y, 
     col=ifelse(datafunctions$f4==1, "blue", "red"), 
     pch=20,
     main = "f4",
     ylab = "",
     xlab = "")
```

# Ejercicio de Ajuste del Algoritmo Perceptron