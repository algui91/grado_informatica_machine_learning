---
title: "Aprendizaje Automático - Práctica 1"
author: "Alejandro Alcalde"
date: "March 3, 2016"
mainfont: Ubuntu Light
monofont: "Ubuntu Mono"
fontsize: 12pt
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    highlight: zenburn
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1000000007)
```



# Ejercicio de Generación y Visualización de datos

## Ejercicio 1

Construir una función _lista = simula_unif (N, dim, rango)_ que calcule una lista de longitud _N_ de vectores de dimensión _dim_ conteniendo números aleatorios uniformes en el intervalo _rango_.

```{r}
simula_unif <- function(N, dimen = 1, rango = c(0:1)) {
  # Generate a list of vectors populated with uniform distributed random numbers
  #
  # Args:
  #   N: Length of the list
  #   dimen: The dimension of each vector in the list
  #   rango: Range to use generating the numbers
  #
  # Returns:
  #   A list of vectors populated randomly
  array(runif(dimen*N, rango[1], rango[2]), dim = c(N, dimen))
}

simula_unif(10, 5, c(10,100))
simula_unif(10, 2)
simula_unif(10)
```

## Ejercicio 2

Construir una función _lista = simula_gaus(N, dim, sigma)_ que calcule una lista de longitud _N_ de vectores de dimensión _dim_ conteniendo números aleatorios gaussianos de media 0 y varianza dadas por el vector de _sigma_.

```{r}
simula_gauss <- function(N, dimen = 1, sig = 1){
  # Generate a list of vectors populated using the normal (Gaussian) distribution
  #
  # Args:
  #   N: Length of the list
  #   dimen: The dimension of each vector in the list
  #   sigma: Vector of Standard deviations
  #
  # Returns:
  #   A list of vectors populated randomly
  array(rnorm(dimen*N, sd = sig), dim = c(dimen, N))
}

simula_gauss(10, 5, c(1,2))
```

## Ejercicio 3

Suponer _N=50, dim=2, rango=[-50,+50]_ en cada dimensión. Dibujar una gráfica de la salida de la función correspondiente.

```{r}
datos = simula_unif(50, 2, c(-50,50)); datos
plot(datos[1,],datos[2,], col=2, xlab="x",ylab="y", 
     main="Gráfica datos de simula_unif(50, 2, c(-50,50))")
plot(datos[1,],datos[2,], col = "red", type = "b", 
     main = "Gráfica datos de simula_unif(50, 2, c(-50,50))", lwd = 2, lty = 3)
```

## Ejercicio 4

Suponer _N=50, dim=2, $\sigma=[5,7]$_ dibujar una gráfica de la salida de la función correspondiente.

```{r}
datos = simula_gauss(50, 2, c(5,7)); datos

plot(datos[1,],datos[2,], col=2, xlab="x",ylab="y", 
     main="Gráfica datos de  simula_gauss(50, 2, c(5,7))")
# points(datos[1,],datos[2,])
plot(datos[1,],datos[2,], col = "red", type = "b",
     main = "Gráfica datos de simula_gauss(50, 2, c(5,7))", lwd = 2, lty = 3)
```

## Ejercicio 5

Construir la función _v = simula_recta(intervalo)_ que calcula los parámetros _v = (a,b)_ de una recta aleatoria, _y = ax + b_, que corte al cuadrado _[-50, 50] x [-50, 50]_.

```{r}

simula_recta <- function(interval = c(-50, 50)){
  # Computes the slope and intercept values of two points in the given interval
  #
  # Args:
  #   interval: Interval from which to pick to random points
  #
  # Returns:
  #   A vector [m, l, p1, p2] where:
  #     - m is the slope 
  #     - l is the intercept
  #     - p1, p2, are the points randomly selected
  p1 = runif(2, interval[1], interval[2]);
  p2 = runif(2, interval[1], interval[2]);
  
  ## Compute the slope
  m = (p1[2] - p2[2]) / (p1[1] - p2[1])
  
  # Compute y − y1 = m(x − x1)
  line = m * (p1[1] - p2[1]) + p2[2]
  
  c(m, line, p1, p2)
}

interval = c(-100, 100);
result = simula_recta(interval)
m = result[1]
line = result[2]
p1 = c(result[3],result[4])
p2 = c(result[5], result[6])
data = rbind(p1, p2)

plot(interval, interval, type= "n", 
     sub = paste(c("p1=", p1, "p2=", p2), collapse = " "), 
     main = "Line that passes throught points P1, P2",
     xlab = paste(c("m=", m, "line=", line), collapse = " "),
     ylab = "")
points(p1, p2)
lines(p1, p2, lty="solid", col="red")
```

## Ejercicio 6

Generar una muestra 2D de puntos usando _simula_unif_ y etiquetar la muestra usando el signo de la función $f(x,y) = y - ax - b$ de cada punto a una recta simulada con _simula_recta_. Mostrar una gráfica con el resultado de la muestra etiquetada junto con la recta usada para ello.

```{r}
interval = c(-100, 100)
# Generate a set of points
x = simula_unif(1000, 2, interval);

fsign <- function(x, y, m, b){
  # Function to label a 2D Point
  y - m*x - b
}

straight = simula_recta(interval)
m = straight[1]
line = straight[2]
p1 = c(straight[3],straight[4])
p2 = c(straight[5], straight[6])

# Apply fsign to each point of the set, each x,y will be passed to fsign
result = mapply(fsign, x[,1], x[,2], m = m, b = line);
# Create a data frame to store the result
data = data.frame(x = x[,1], y = x[,2])
data$Result = c(result)
data$Colour[data$Result<0] = "red"
data$Colour[data$Result>=0] = "blue"

# Draw the result
plot(data$x,data$y, col=data$Colour, pch=20,
     main = "Points labeled in function of y - m*x - b",
     xlab = paste(c("m=", m, "line=", line), collapse = " "),
     sub = paste(c("Interval = ", interval), collapse = " "),
     ylab = "")
abline(line,m)
```

# Ejercicio de Ajuste del Algoritmo Perceptron